name: Test Poosh Action (Local)

on:
  push:
  pull_request:
  workflow_dispatch:

jobs:
  local-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Run local Poosh tests
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const os = require('os');
          const path = require('path');
          const { execSync } = require('child_process');
          const assert = require('assert');

          const DEFAULT_PR_BODY =
            'This PR was generated by [Poosh](https://github.com/BobTheBuidler/poosh) as part of a GitHub Actions workflow';
          const REPO_SLUG = process.env.GITHUB_REPOSITORY || 'local/poosh';

          const run = (cmd, cwd) => execSync(cmd, { cwd, stdio: 'pipe' });
          const output = (cmd, cwd) => execSync(cmd, { cwd, encoding: 'utf8' }).trim();

          const writeHook = (bareRepo, rejectBranch) => {
            const hookPath = path.join(bareRepo, 'hooks', 'pre-receive');
            const hook = [
              '#!/bin/sh',
              'while read old new ref; do',
              `  if [ "$ref" = "refs/heads/${rejectBranch}" ]; then`,
              '    echo "reject" >&2',
              '    exit 1',
              '  fi',
              'done',
              'exit 0',
            ].join('\n');
            fs.writeFileSync(hookPath, hook);
            fs.chmodSync(hookPath, 0o755);
          };

          const setupRepo = ({ defaultBranch = 'main', rejectBranch } = {}) => {
            const base = fs.mkdtempSync(path.join(os.tmpdir(), 'poosh-test-'));
            run('git init --bare -q remote.git', base);
            const bare = path.join(base, 'remote.git');
            if (rejectBranch) {
              writeHook(bare, rejectBranch);
            }

            const repo = path.join(base, 'repo');
            fs.mkdirSync(repo, { recursive: true });
            run('git init -q', repo);
            run('git config user.name "Test Bot"', repo);
            run('git config user.email "test@example.com"', repo);
            fs.writeFileSync(path.join(repo, 'file.txt'), 'hello\n');
            run('git add .', repo);
            run('git commit -q -m "init"', repo);
            run(`git branch -M ${defaultBranch}`, repo);
            run(`git remote add origin ${bare}`, repo);
            run(`git push -u origin ${defaultBranch}`, repo);
            return { base, repo, bare };
          };

          const withRepo = (opts, fn) => {
            const ctx = setupRepo(opts);
            try {
              fn(ctx);
            } finally {
              fs.rmSync(ctx.base, { recursive: true, force: true });
            }
          };

          const remoteBranchExists = (repo, branch) => {
            try {
              execSync(`git ls-remote --exit-code --heads origin ${branch}`, {
                cwd: repo,
                stdio: 'ignore',
              });
              return true;
            } catch {
              return false;
            }
          };

          const ensureValidBranch = (value, label) => {
            if (value && !/^[a-zA-Z0-9._/-]+$/.test(value)) {
              throw new Error(
                `ERROR: '${label}' contains invalid characters. Only alphanumeric, '.', '_', '-', and '/' are allowed.`
              );
            }
          };

          const runPoosh = (repo, inputs) => {
            const commitMessage = inputs.commitMessage || '';
            if (!commitMessage.trim()) {
              throw new Error("ERROR: 'commit-message' is required and must be a non-empty string.");
            }

            const triggerBranch = inputs.triggerBranch || '';
            if (!triggerBranch.trim()) {
              throw new Error("ERROR: 'trigger-branch' is required and must be a non-empty string.");
            }

            ensureValidBranch(triggerBranch, 'trigger-branch');
            ensureValidBranch(inputs.prBranch || '', 'pr-branch');
            ensureValidBranch(inputs.prBase || '', 'pr-base');

            const outputs = {
              triggerBranch,
              commitSha: '',
              prUrl: '',
              prNumber: '',
            };

            const currentBranch = output('git rev-parse --abbrev-ref HEAD', repo);
            if (currentBranch !== triggerBranch) {
              if (remoteBranchExists(repo, triggerBranch)) {
                run(`git fetch origin ${triggerBranch}:${triggerBranch}`, repo);
                run(`git checkout ${triggerBranch}`, repo);
                run(`git pull origin ${triggerBranch}`, repo);
              }
            }

            run('git add .', repo);
            let changed = true;
            try {
              execSync('git diff --cached --quiet', { cwd: repo, stdio: 'ignore' });
              changed = false;
            } catch {
              changed = true;
            }

            if (!changed) {
              return outputs;
            }

            run('git config --local user.name "github-actions[bot]"', repo);
            run('git config --local user.email "github-actions[bot]@users.noreply.github.com"', repo);
            const safeMessage = commitMessage.replace(/"/g, '\\"');
            run(`git commit -m "${safeMessage}"`, repo);
            outputs.commitSha = output('git rev-parse HEAD', repo);

            let pushSuccess = true;
            try {
              run(`git push origin "HEAD:${triggerBranch}"`, repo);
            } catch {
              pushSuccess = false;
            }

            if (pushSuccess) {
              return outputs;
            }

            let prBranch = inputs.prBranch || '';
            if (!prBranch) {
              prBranch = `poosh/${triggerBranch}`;
            } else if (!prBranch.includes('/')) {
              prBranch = `poosh/${prBranch}`;
            }

            run(`git checkout -b ${prBranch}`, repo);
            run(`git push origin ${prBranch}`, repo);

            const prBase = inputs.prBase || triggerBranch;
            const prBody = inputs.prBody || DEFAULT_PR_BODY;
            const body = inputs.triggerPrNumber
              ? `${prBody}\n\n[Triggered by PR #${inputs.triggerPrNumber}](https://github.com/${REPO_SLUG}/pull/${inputs.triggerPrNumber})`
              : `${prBody}\n\n[Triggered by recent changes on branch \`${triggerBranch}\`](https://github.com/${REPO_SLUG}/tree/${triggerBranch})`;

            outputs.prUrl = `https://example.com/${prBranch}`;
            outputs.prNumber = '1';
            outputs.prBase = prBase;
            outputs.prBranch = prBranch;
            outputs.prBody = body;

            return outputs;
          };

          const testNoChanges = () =>
            withRepo({}, ({ repo }) => {
              const outputs = runPoosh(repo, {
                commitMessage: 'test: no changes',
                triggerBranch: 'main',
              });
              assert.strictEqual(outputs.triggerBranch, 'main');
              assert.strictEqual(outputs.commitSha, '');
              assert.strictEqual(outputs.prUrl, '');
            });

          const testPushSuccess = () =>
            withRepo({}, ({ repo }) => {
              fs.appendFileSync(path.join(repo, 'file.txt'), 'change\n');
              const outputs = runPoosh(repo, {
                commitMessage: 'test: push success',
                triggerBranch: 'main',
              });
              assert.ok(outputs.commitSha);
              assert.strictEqual(outputs.prUrl, '');
            });

          const testPushFailureCreatesPr = () =>
            withRepo({ rejectBranch: 'blocked' }, ({ repo }) => {
              fs.appendFileSync(path.join(repo, 'file.txt'), 'change\n');
              const outputs = runPoosh(repo, {
                commitMessage: 'test: pr fallback',
                triggerBranch: 'blocked',
                prBranch: 'custom',
                prBase: 'main',
                triggerPrNumber: '123',
              });
              assert.ok(outputs.commitSha);
              assert.ok(outputs.prUrl);
              assert.strictEqual(outputs.prBase, 'main');
              assert.strictEqual(outputs.prBranch, 'poosh/custom');
              assert.ok(remoteBranchExists(repo, outputs.prBranch));
            });

          const testInvalidTriggerBranch = () => {
            assert.throws(
              () =>
                withRepo({}, ({ repo }) =>
                  runPoosh(repo, {
                    commitMessage: 'test: invalid branch',
                    triggerBranch: 'bad^branch',
                  })
                ),
              /trigger-branch/
            );
          };

          const main = () => {
            testNoChanges();
            testPushSuccess();
            testPushFailureCreatesPr();
            testInvalidTriggerBranch();
            console.log('All tests passed.');
          };

          main();
          NODE
